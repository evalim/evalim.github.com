---
layout: post
title: "用双眼识别条形码"
date: 2013-04-30 15:22
comments: true
categories: 笔记 JavaScript
---
### 条形码  
条形码应用的广泛程度不用我去赘述，随便拿起身边的饮料瓶或一本书，很容易便会发现印在其包装或封底的条形码。条形码被誉为印在纸上的机器语言，因为其记录的信息非常方便用机器读取。  
条形码的格式丰富多样，每一种格式都有特定的编码规则，其中EAN-13格式最为常见。EAN是“European Article Number”的简写，13代表代码长度。最初EAN只是欧洲范围内使用，但是现在已经成了全球范围内产品交易的上平代码。你看到的书、喝的果汁、吃的饼干这些商品包装上的条形码都是采用这种格式。  
#### 基本结构  
EAN-13的每一位数字都有特定含义，但是我不打算去细究这些东西，如果有兴趣请移步维基百科上[关于EAN的介绍](http://zh.wikipedia.org/wiki/EAN)。现在只需要把EAN-13分为两个部分：前12位和最后1位。前12位称为数据位，最后一位称为校验位。 
<!-- more --> 
#### 更细基本单位  
条形码的可读范围从最左边的第一条黑条开始，一直到最右边的黑条。仔细看你会发现最左和最右的黑条是最细的，再仔细看你又会发现中间的那些宽一点的黑条只会是最左边黑条的2倍、3倍或4倍宽。如果把最左黑条旁边的白色空隙看做白条，你会发现这一条白条和最细的黑条一样宽，而且是所有白条中最细的，中间的宽一点的白条都是这条白条的2倍、3倍或4倍。如果你发现某个条形码最宽的黑条/白条比最窄的黑条/白条宽4倍以上，那么这个条形码一定是错误的或者被篡改了。  
且将最窄的黑条记为`1`，最窄的白条记为`0`，那么如下图所示的条形码就可以记为`1010011101`  
![barcode](/images/blog/2013043001.png)  
如果你的眼睛足够犀利，那么任何黑白交错的条形码都能被你的双眼转换为类似上面的`01`串，这正是识别条形码的基础，有了这些`01`串，就可已进入下一步识别步骤了，不过在进入下一步之前，请再仔细观察一下条形码。  
条形码最左边的3条（101）、最右边的三条、和中间的5条（01010）都会比其它的条形要长一点，这三个区域叫做这个二维码的护线，二维码的数据位或校验位的信息并不会记录在这3个区域当中，他们存在的作用仅仅是告诉识别机器它们是这段条形码的开始、中间和结束部分，并且他们的黑条和白条是最窄的，是其它条形宽度的参考。  
#### 数据组成  
擦亮大家的双眼，一起来把下面的条形码翻译成`01`串，其中护线和数据位可以稍微留一点空白便于区分  
![barcode](/images/blog/2013043002.png)  
我的得到的结果是：  
`101`  
`011101100010010010001001100100110110011001`  
`01010`  
`110011010010001100110110011010010001011100`  
`101`  
把上面的护线部分忽略掉，把剩下的串按每7位组成一个部分，我们将得到下面这样的更细的片段：  
左边 `0111011` `0001001` `0010001` `0011001` `0011011` `0011001`  
右边 `1100110` `1001000` `1100110` `1100110` `1001000` `1011100`  
上面的每一个部分都只表示一个数字。按照这个规则上面刚好只有12个数，和之前所说的13个数字有偏差。那另外一个数字丢哪里了呢？请继续看下去。  
看看上面的数字，你会发现一个规律，左边的每一个数字都是以`0`开头、以`1`结尾，右边的数字则刚好相反。这正是条形码的查错方式之一，如果发现读取的条形码不符合上面规则，那么这个条形码是有错误的。  
接下来将上面的各个待解读的数字分为两类：有奇数个`1`的奇类、有偶数`1`的偶类。例如，`0111011`有奇数个`1`，`0001001`有偶数个`1`。根据这个分类你会发现，左边的部分有一些是奇类有一些是偶类，右边的全是偶类。如果你在读取过程中发现右边的部分中存在奇类，那么这个条形码一定是错误的。  
下面是这些`01`串和数字的对应规则：
> 奇类  
> 0001101 -> 0　　0110001 -> 5  
> 0011001 -> 1　　0101111 -> 6  
> 0010011 -> 2　　0111011 -> 7  
> 0111101 -> 3　　0110111 -> 8  
> 0100011 -> 4　　0001011 -> 9  

> 偶类  
> 1110010 -> 0　　1001110 -> 5  
> 1100110 -> 1　　1010000 -> 6  
> 1101100 -> 2　　1000100 -> 7  
> 1000010 -> 3　　1001000 -> 8  
> 1011100 -> 4　　1110100 -> 9  


现在可以开始读数字了，左边第一个是`0111011`，属于奇类，根据对应规则得到的数字是7。左边第二个是`0001001`，属于偶类，可是找遍所有的偶类规则都不能匹配。还是条形码有问题？还是我们的01串读错了？其实左边的偶类在读取的时候是要逆向读的，也就是说，刚刚的`0001001`先要转换成`1001000`然后再去偶类规则里去找对应的数字。现在我们很容易就找到第二个对应数字是8。依次类推，我们把剩下的数字都能读出来，最后的结果应该是`787121`和`181184`。  
之前悬着的问题是时候面对了——说好的13个数字呢？！其实这个被遗忘的数字就藏在`01`串当中，如果把`01`串左边的部分的奇类看为`1`，偶类看为`0`，那么左边会得到一个新的6位串`100101`，这个串的读取规则如下：  
> 111111 -> 0　　100110 -> 5  
> 110100 -> 1　　100011 -> 6  
> 110010 -> 2　　101010 -> 7  
> 110001 -> 3　　101001 -> 8  
> 101100 -> 4　　100101 -> 9  

根据规则，得到的数字是9。把这个数字和之前读取的数字连起来就是`978712118184`，掏出手机扫描一下即可验证其是正确的。  
#### 校验规则  
条形码有一个非常重要的特点就是防止篡改，这在实际使用中是非常重要的。根据EAN-13规则，`978712118184`的最后一个数字`4`是校验位，用于检验前面的数字是否被修改过，具体的检验步骤如下：  
1. 取数据位中的奇数位求和得到S1  
2. 取数据位中的偶数位求和得到S2  
3. S3 = S1 + S2 * 3  
4. M = S3 % 10（取S3的个位数）  
5. C = 10 - M  

C就是最后的校验结果，这个结果和第13位做比较，如果不同就代表数据有问题。  
结合上面的奇类偶类读取规则不难发现，简单的涂改一定会导致条形码出错的。不过这也是条形码的一个短处所在，如果不经意之间损坏了条形码的结构，哪怕只有一条，都会导致其中的信息完全失效，也就是说条形码没有容错功能。那么有没有既有防篡改又能纠错的条形码呢？答案是肯定的，这个“条形码”叫做“二维码”！  

### 生成条形码  
知道了EAN-13的规则，就可以动手写一个生成条形码的应用了。输入一个12位（不含校验的情况）或13位数字，就能生成相应的条形码：  
<div style='background:rgba(133, 133, 133, 0.1); margin:0 auto'>
	<span>输入12位或13位数字：</span>
	<input type='text' value='978712118184' id='in'>
	<button onclick='create()'>Create</button><br>
	<canvas id='c' width='400px' height='300px'></canvas>
	<script>
// 左边的规则
function leftCode(number, o) {
    if(o == '1')
		return [
			'0001101', '0011001', '0010011', '0111101', '0100011',
			'0110001', '0101111', '0111011', '0110111', '0001011'][parseInt(number)%10];
	else {
		return [
			'0100111', '0110011', '0011011', '0100001', '0011101',
			'0111001', '0000101', '0010001', '0001001', '0010111'][parseInt(number)%10];
	}
}

// 右边的规则
function rightCode(number) {
	return [
		'1110010', '1100110', '1101100', '1000010', '1011100',
		'1001110', '1010000', '1000100', '1001000', '1110100'][parseInt(number)%10];
}

// 隐含数字的规则
function ISBNLeftRule(number) {
	return [
		'111111', '110100', '110010', '110001', '101100',
		'100110', '100011', '101010', '101001', '100101'][parseInt(number)%10];
}

function createEAN13(series) {
	var result = '101';
	var rule = ISBNLeftRule(series[0]);
	for(var i = 1; i < 7; ++i) {
		result += leftCode(series[i], rule[i-1]);
	}
	result += '01010';
	for(var i = 7; i < 13; ++i) {
		result += rightCode(series[i]);
	}
	result += '101';
	return result;
}

// 校验规则
function checkEAN13(series, mode) {
	var sum = 0;
	for(var i = 0; i < 6; ++i) {
		sum += parseInt(series[i*2]);
		sum += parseInt(series[i*2 + 1]) * 3;
	}
	sum = 10 - (sum % 10);
	if(mode == true)
		return sum + '';
	if(parseInt(series[12]) == sum)
		return true;
	return false;
}

function draw(ctx, series) {
	ctx.clearRect(0, 0, 1000, 1000);
	if(series.length == 12) {
		series = series + checkEAN13(series, true);
	} else if(checkEAN13(series) == false) {
		ctx.fillStyle = 'black';
		ctx.fillText('check failed!', 10, 30);
		return ;
	}
	var WIDTH = 4;		// 条码宽度
	var HEIGHT = 200;	// 条码高度
	var bc = createEAN13(series);
	ctx.fillStyle = 'black';
	for(i = 0; i < 3; ++i) {
		if(bc[i] == '1') {
			ctx.fillRect(i*WIDTH, 20, WIDTH, HEIGHT+25);
		}
	}
	for(; i < 45; ++i) {
		if(bc[i] == '1') {
			ctx.fillRect(i*WIDTH, 20, WIDTH, HEIGHT);
		}
	}
	for(; i < 50; ++i) {
		if(bc[i] == '1') {
			ctx.fillRect(i*WIDTH, 20, WIDTH, HEIGHT+25);
		}
	}
	for(; i < 92; ++i) {
		if(bc[i] == '1') {
			ctx.fillRect(i*WIDTH, 20, WIDTH, HEIGHT);
		}
	}
	for(; i < 95; ++i) {
		if(bc[i] == '1') {
			ctx.fillRect(i*WIDTH, 20, WIDTH, HEIGHT+25);
		}
	}
}

function create() {
	var ctx = document.getElementById('c').getContext('2d');
	var text = document.getElementById('in').value;
	draw(ctx, text);
}
create();
</script>
</div>
下面是JavaScript代码链接:  
[https://gist.github.com/GZShi/5487022](https://gist.github.com/GZShi/5487022)